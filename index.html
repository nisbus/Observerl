<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Observerl : " />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Observerl</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/nisbus/Observerl">View on GitHub</a>

          <h1 id="project_title">Observerl</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/nisbus/Observerl/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/nisbus/Observerl/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>Welcome to Observerl.</h3>

<p>Observerl is a process for filtering and aggregating streams of data based on subscriber preferences.
   It is inspired by the Reactive Extensions by Microsoft.
</p>

<h3>How it works</h3>

<p>You start by creating your datastream that can be anything really.
   You then need some way for your subscribers to call the application with their subscription request (Websockets?).
   When a request is received, your application should create a new observer for the subscriber and feed it the filters
provided by the subscriber. Then you need to have your datastream call the on_next(Value) of the observer 
for each value that it produces.
When an observer receives a value it will go through all of it's subscribers and run the filters provided earlier.
If the value received passes through all the filters it is then put through the aggregator (optionally provided by the subscriber).
The final pass is to check if the subscriber is windowing the data and if so the value is pushed to the subscribers window which will 
notify the subscriber of new data when it arrives.</p>

<h3>Filters</h3>

<p>Filters are just simple erlang functions that return either true or false.
The subscriber can send in his filters as erlang funs or as a string representation of an erlang fun.</p>

<h3>Aggregator</h3>

<p>The aggregator function provided by the subscriber is defined the same way as the filter functions but there can only be
one aggregator function per subscriber.
It takes the form fun(X,Y) -> any() end. where X is the new value and Y is the current aggregated value.</p>

<h3>Window</h3>

<p>The subscriber can define a window for which the data will be aggregated.
There are two types of windows:
  <ul>
    <il> Time based </il>
    <il> Size based </il>
  </ul>
  Time based windows collect the data for a specified timeframe and notify the subscriber with all the data for the 
  time-frame on each tick (provided by the subscriber).
  Size based windows collect the incoming data until it reaches the size given by the subscriber.
  When the size is reached, the window will notify the subscriber with the latest # of values equal to the size of the
  window.
</p>

<h3>Documentation</h3>
<p>
  You can find the code documentation <a href="http://nisbus.github.com/Observerl/doc/index.html">here</a>
</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Observerl maintained by <a href="https://github.com/nisbus">nisbus</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
